<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>List (pred.Pred.List)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">pred</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Pred.List</span></h1></header><div class="doc"><p>lists are singly-linked, immutable lists of objects.</p><p>they are represented syntactically as <code class="code">[a0; a1; ... an]</code>.</p><p>the base constructors for <code class="code">'a list</code> are:
</p><ul><li><code class="code">[]</code>, which creates an empty list</li><li><code class="code">(x: 'a) :: (xs: 'a list)</code>,
which returns the list <code class="code">xs</code> with <code class="code">x</code> appended to the front.
<code class="code">xs</code> is not mutated at all.</li></ul></div><div class="spec module" id="module-Caml"><a href="#module-Caml" class="anchor"></a><div class="def module"><code><span class="keyword">module </span>Caml : <span class="keyword">module type of </span><a href="../../../pred.caml/Pred_caml_stdlib/index.html#module-List">Pred_caml_stdlib.List</a></code></div><div class="doc"><p>an alias for the original <code class="code">List</code> module from the OCaml standard library.</p></div></div><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a t</code><code><span class="keyword"> = </span><span class="type-var">'a</span> list</code><code></code></div><div class="doc"><p>type alias</p></div></div><h2>list operations</h2><div class="spec val" id="val-hd"><a href="#val-hd" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>hd : <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> option</code></div><div class="doc"><p><code class="code">hd xs</code> returns the first element of <code class="code">xs</code> if it isn't empty;
otherwise, it returns <code class="code">None</code>.</p></div></div><div class="spec val" id="val-tl"><a href="#val-tl" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tl : <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list option</code></div><div class="doc"><p><code class="code">tl xs</code> returns <code class="code">xs</code> without the first element,
if <code class="code">xs</code> isn't empty.
otherwise, it returns <code class="code">None</code>.</p><p>e.g., <code class="code">tl (x :: xs)</code> returns <code class="code">Some xs</code></p></div></div><div class="spec val" id="val-nth"><a href="#val-nth" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>nth : int <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> option</code></div><div class="doc"><p><code class="code">nth n [a0; a1; ... am]</code> returns <code class="code">Some an</code>,
if there is an <code class="code">n</code>-th element.
if <code class="code">n &gt;= length xs</code>, then returns <code class="code">None</code>.</p><p>has <code class="code">O(n)</code> time complexity.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: if <code class="code">n &lt; 0</code></li></ul></div></div><div class="spec val" id="val-length"><a href="#val-length" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>length : <span class="type-var">_</span> list <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">length xs</code> returns the number of elements in <code class="code">xs</code>.
has <code class="code">O(length xs)</code> time complexity.</p></div></div><div class="spec val" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>is_empty : <span class="type-var">_</span> list <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p>equivalent to <code class="code">length xs = 0</code>,
except that it has <code class="code">O(1)</code> time complexity.</p></div></div><h2>constructors</h2><div class="spec val" id="val-nil"><a href="#val-nil" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>nil : <span class="type-var">'a</span> list</code></div><div class="doc"><p>returns the empty list, <code class="code">[]</code>, for any type.</p></div></div><div class="spec val" id="val-cons"><a href="#val-cons" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cons : <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list</code></div><div class="doc"><p><code class="code">cons x xs</code> is equivalent to <code class="code">x :: xs</code> -
basically, appends <code class="code">x</code> to the front of <code class="code">xs</code>,
and returns the new list.</p></div></div><div class="spec val" id="val-map"><a href="#val-map" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>map : (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> list</code></div><div class="doc"><p><code class="code">map f as</code> returns a new list,
created by applying <code class="code">f</code> to each element in <code class="code">as</code>.</p><p>i.e., <code class="code">map f [a0; a1; ... an]</code> returns <code class="code">[f a0; f a1; ... f an]</code>.</p><p>unlike <code class="code">Caml.map</code>, this version is tail recursive,
and guaranteed to run in <code class="code">O(1)</code> stack space.</p></div></div><div class="spec val" id="val-rev"><a href="#val-rev" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>rev : <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list</code></div><div class="doc"><p><code class="code">rev xs</code> returns a new list, created by reversing <code class="code">xs</code>.</p><p>i.e., <code class="code">rev [a0; a1; ... an]</code> returns <code class="code">[an; a(n - 1); ... a0]</code></p></div></div><div class="spec val" id="val-rev_map"><a href="#val-rev_map" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>rev_map : (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> list</code></div><div class="doc"><p><code class="code">rev_map f as</code> returns a new list,
created by applying <code class="code">f</code> to each element in <code class="code">as</code>,
applied from the back to the front of the list.</p><p>i.e., <code class="code">rev_map f [a0; a1; ... an]</code> returns <code class="code">[f an; f a(n - 1); ... f a0]</code>.</p><p>equivalent to <code class="code">map f (rev as)</code>, but more efficient.</p></div></div><div class="spec val" id="val-append"><a href="#val-append" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>append : <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list</code></div><div class="doc"><p><code class="code">append xs ys</code> returns a new list with each element in <code class="code">xs</code> in front of <code class="code">ys</code>.</p><p>i.e., <code class="code">append [a0; a1; ... an] [b0; b1; ... bn]</code>
returns <code class="code">[a0; a1; ... an; b0; b1; ... bn]</code>.</p><p>has <code class="code">O(length xs)</code> time complexity,
and uses <code class="code">O(length xs)</code> stack space.</p></div></div><div class="spec val" id="val-flatten"><a href="#val-flatten" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>flatten : <span class="type-var">'a</span> list list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list</code></div><div class="doc"><p><code class="code">flatten xs</code> returns a new list,
created by expanding out each element of <code class="code">xs</code> into the new list.</p><p>i.e., <code class="code">flatten [[a0; a1; ... an]; [b0; b1; ... bn]; ... xn]</code>
returns <code class="code">[a0; a1; ... an; b0; b1; ... bn; ... ]</code>.</p><p>uses <code class="code">O(n)</code> stack space, where <code class="code">n</code> is the longest list in <code class="code">xs</code>.</p></div></div><div class="spec val" id="val-concat"><a href="#val-concat" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>concat : <span class="type-var">'a</span> list list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list</code></div><div class="doc"><p>an alias for <a href="index.html#val-flatten">flatten</a></p></div></div><div class="spec val" id="val-flat_map"><a href="#val-flat_map" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>flat_map : (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> list) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> list</code></div><div class="doc"><p><code class="code">flat_map f [a0; a1; ... an]</code>,
where <code class="code">f an</code> generates <code class="code">[bn0; bn1; ... bnn]</code>,
generates <code class="code">[b00; b11; ... ; b10; b11; ... ; ...]</code>.</p><p>equivalent to <a href="index.html#val-map">map</a> followed by <a href="index.html#val-flatten">flatten</a>,
but more efficient.</p><p>uses <code class="code">O(n)</code> stack space,
where <code class="code">n</code> is the longest list returned by <code class="code">f</code>.</p></div></div><h2>iteration</h2><div class="spec val" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>to_seq : <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="../Seq/index.html#type-t">Seq.t</a></code></div><div class="doc"><p><code class="code">to_seq [a0; a1; ... an]</code> generates the sequence <code class="code">&lt;a0; a1; ... an&gt;</code>.</p></div></div><div class="spec val" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>of_seq : <span class="type-var">'a</span> <a href="../Seq/index.html#type-t">Seq.t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list</code></div><div class="doc"><p><code class="code">of_seq &lt;a0; a1; ... an&gt;</code> creates the list <code class="code">[a0; a1; ... an]</code>.</p></div></div><div class="spec val" id="val-fold"><a href="#val-fold" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>fold : <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span></code></div><div class="doc"><p><code class="code">fold a f [b0; b1; ... bn]</code> is <code class="code">f (... (f (f a b0) b1) ...) bn</code>.</p></div></div><div class="spec module" id="module-Monad"><a href="#module-Monad" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Monad/index.html">Monad</a> : <a href="../Interfaces/Monad/index.html#module-type-Interface">Interfaces.Monad.Interface</a><span class="keyword"> with </span><span class="keyword">type </span>'a <a href="../Interfaces/Monad/module-type-Interface/index.html#type-t">t</a><span class="keyword"> = </span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"></div></div></body></html>