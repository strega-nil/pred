<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Monad (pred.Pred__.Interfaces.Monad)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../../index.html">pred</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Pred__.Interfaces.Monad</span></h1></header><div class="doc"><p>the infamous burrito of functional programming lore.</p><p>an implementation must give two functions:
</p><ul><li><code class="code">wrap</code>, which takes a value and wraps it</li><li><code class="code">&gt;&gt;=</code>, prounounced bind, which calls a function on the wrapped value</li></ul><p>for more information, see
<a href="https://wiki.haskell.org/Monad">the Haskell wiki</a>;
note that Haskell uses the term <code class="code">return</code>,
where <code class="code">Pred</code> uses <code class="code">wrap</code>.</p><p>any implementation of <code class="code">Monad</code> should follow these laws:
</p><ul><li><code class="code">(wrap a &gt;&gt;= k) = (k a)</code></li><li><code class="code">(m &gt;&gt;= wrap) = m</code></li><li><code class="code">(m &gt;&gt;= (fun x -&gt; k x &gt;&gt;= h)) = ((m &gt;&gt;= k) &gt;&gt;= h)</code></li></ul><p>in words:
</p><ul><li>wrap and then bind should be equivalent to doing nothing</li><li>bind and then wrap should be equivalent to doing nothing</li><li>it should not matter whether bind is associated left, or right</li></ul><p>The monad in this module also allows for associated comonadic data.
For example, a compiler might have a <code class="code">span</code> type,
which should go along with each item.
If a type's monad does not have comonadic data,
then <code class="code">type 'a comonad = 'a</code> suffices.</p></div><div class="spec module-type" id="module-type-Implementation"><a href="#module-type-Implementation" class="anchor"></a><div class="def module-type"><code><span class="keyword">module type </span><a href="module-type-Implementation/index.html">Implementation</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec module-type" id="module-type-Interface"><a href="#module-type-Interface" class="anchor"></a><div class="def module-type"><code><span class="keyword">module type </span><a href="module-type-Interface/index.html">Interface</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-M/index.html">M</a> : <a href="index.html#module-type-Implementation">Implementation</a>) -&gt; <a href="index.html#module-type-Interface">Interface</a><span class="keyword"> with </span><span class="keyword">type </span>'a <a href="Make/index.html#type-t">t</a><span class="keyword"> = </span><span class="type-var">'a</span> <a href="Make/argument-1-M/index.html#type-t">M.t</a><span class="keyword"> and </span><span class="keyword">type </span>'a <a href="Make/index.html#type-comonad">comonad</a><span class="keyword"> = </span><span class="type-var">'a</span> <a href="Make/argument-1-M/index.html#type-comonad">M.comonad</a></code></div><div class="doc"></div></div></body></html>